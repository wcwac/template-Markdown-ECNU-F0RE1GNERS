# 编译原理实验1

## 代码

* 需要 C++11

```cpp
#include<bits/stdc++.h>

using namespace std;

enum {
    Comment = 0, Main, If, Then, While, Do, Static, Int, Double, Struct,
    Break, Else, Long, Switch, Case, Typedef, Char, Return, Const, Float,
    Short, Continue, For, Void, Sizeof, ID, NUM, ADD, SUB, MUL,
    DIV, COLON, DEFINE, LT, NE, LE, GT, GE, EQ, Default,
    Do1, SEMI, LB, RB
};

char name[][10] = {
        "Comment", "Main", "If", "Then", "While", "Do", "Static", "Int", "Double", "Struct",
        "Break", "Else", "Long", "Switch", "Case", "Typedef", "Char", "Return", "Const", "Float",
        "Short", "Continue", "For", "Void", "Sizeof", "ID", "NUM", "ADD", "SUB", "MUL",
        "DIV", "COLON", "DEFINE", "LT", "NE", "LE", "GT", "GE", "EQ", "Default",
        "Do1", "SEMI", "LB", "RB"
};


struct Token {
    int syn = 0;
    string token;
    int val = 0;

    void print() const {
        if (syn == -2) {
            printf("<%d,%s>\n", syn, token.c_str());
            return;
        }
        if (syn == NUM) {
            printf("<%d,", syn);
            for (int i = 31; i >= 0; --i) {
                printf("%d", (val >> i) & 1);
            }
            printf("b>\n");
        }
//        else if (syn == ID)
//            printf("<%d,%s>\n", syn, token.c_str());
        else
            printf("<%d,%s>\n", syn, token.c_str());
    }
};


int identifierNum = RB + 1;
unordered_map<string, int> identifier;

void initIdentifier() {
    identifier["#"] = Comment;
    identifier["main"] = Main;
    identifier["if"] = If;
    identifier["then"] = Then;
    identifier["while"] = While;
    identifier["do"] = Do;
    identifier["static"] = Static;
    identifier["int"] = Int;
    identifier["double"] = Double;
    identifier["struct"] = Struct;
    identifier["break"] = Break;
    identifier["else"] = Else;
    identifier["long"] = Long;
    identifier["switch"] = Switch;
    identifier["case"] = Case;
    identifier["typedef"] = Typedef;
    identifier["char"] = Char;
    identifier["return"] = Return;
    identifier["const"] = Const;
    identifier["float"] = Float;
    identifier["short"] = Short;
    identifier["continue"] = Continue;
    identifier["for"] = For;
    identifier["void"] = Void;
    identifier["sizeof"] = Sizeof;
    identifier["default"] = Default;

}

char *p, *lastp;
int line = 0;


Token *next() {
    auto *tk = new Token;
    tk->token = *p;
    while (*p) {//判断字符串是否结束
        if (*p == '\n') {
            printf("%d: ", line, (int) (p - lastp), lastp);
            while (lastp < p) putchar(*(lastp++));
            printf("\n\n");
            ++p;
            lastp = p;
            line = line + 1;
        } else if (isalpha(*p)) {
            tk->syn = ID;
            tk->token = "";
            while (isalpha(*p) || isdigit(*p)) {
                tk->token += *p;
                ++p;
            }
            if (identifier[tk->token] != 0) {
                if (identifier[tk->token] <= RB) {
                    tk->syn = identifier[tk->token];
                } else {
                    tk->val = identifier[tk->token];
                }
            } else {
                tk->val = identifier[tk->token] = ++identifierNum;
            }
            return tk;
        } else if (*p >= '0' && *p <= '9') {
            tk->syn = NUM;
            tk->val = 0;
            tk->token = "";
            while (*p >= '0' && *p <= '9' || isalpha(*p)) {
                if (isalpha(*p)) {
                    tk->syn = -2;
                } else {
                    tk->val = tk->val * 10 + *p - '0';
                }
                tk->token += *p;
                ++p;
            }
            return tk;
        } else {
            tk->token = *p;
            if (*p == '+') {
                ++p;
                tk->syn = ADD;
                return tk;
            } else if (*p == '-') {
                ++p;
                tk->syn = SUB;
                return tk;
            } else if (*p == '*') {
                ++p;
                tk->syn = MUL;
                return tk;
            } else if (*p == '/') {
                ++p;
                if (*p == '*') {
                    while (true) {
                        ++p;
                        if (!*p) {
                            tk->syn = -1;
                            return tk;
                        }
                        while (*p && *p != '*')
                            ++p;
                        if (*p == '*' && *(p + 1) == '/') {
                            p += 2;
                            break;
                        }
                    }
                    continue;
                } else {
                    tk->syn = DIV;
                    return tk;
                }
            } else if (*p == ':') {
                ++p;
                if (*p == '=') {
                    ++p;
                    tk->token += *p;
                    tk->syn = DEFINE;
                } else {
                    tk->syn = COLON;
                }
                return tk;
            } else if (*p == '<') {
                ++p;
                if (*p == '>') {
                    ++p;
                    tk->token += *p;
                    tk->syn = NE;
                } else if (*p == '=') {
                    ++p;
                    tk->token += *p;
                    tk->syn = LE;
                } else {
                    tk->syn = LT;
                }
                return tk;
            } else if (*p == '>') {
                ++p;
                if (*p == '=') {
                    ++p;
                    tk->token += *p;
                    tk->syn = GE;
                } else {
                    tk->syn = GT;
                }
                return tk;
            } else if (*p == '=') {
                ++p;
                tk->syn = EQ;
                return tk;
            } else if (*p == ';') {
                ++p;
                tk->syn = SEMI;
                return tk;
            } else if (*p == '(') {
                ++p;
                tk->syn = LB;
                return tk;
            } else if (*p == ')') {
                ++p;
                tk->syn = RB;
                return tk;
            } else {
                if (!isblank(*p)) {
                    tk->syn = -2;
                    tk->token = "";
                    if (*p && *p != '\n' && !isblank(*p)) {
                        tk->token += *p;
                        ++p;
                    }
                    return tk;
                }
                ++p;
            }
        }
    }
    printf("%d: ", line);
    while (lastp < p) putchar(*(lastp++));
    tk->syn = -1;
    return tk;
}

char s[1000000];

int main() {
    initIdentifier();
    FILE *f = fopen("1.txt", "r");
    fread(s, 1000000, 1000000, f);
    p = lastp = s;
    Token *tk = next();
    while (tk->syn != -1) {
        tk->print();
        tk = next();
    }
    return 0;
}
```
